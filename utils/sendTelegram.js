const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
const geoip = require('geoip-lite');
require('dotenv').config();

// B·ªô ƒë·ªám ƒë·ªÉ theo d√µi IP ƒë√£ ƒë∆∞·ª£c th√¥ng b√°o
// { ip: timestamp } - l∆∞u th·ªùi gian IP cu·ªëi c√πng ƒë∆∞·ª£c g·ª≠i th√¥ng b√°o
const notificationCache = {};

// Th·ªùi gian t·ªëi thi·ªÉu gi·ªØa 2 l·∫ßn g·ª≠i th√¥ng b√°o cho c√πng 1 IP (30 gi√¢y)
const MIN_NOTIFICATION_INTERVAL = 30000; // 30 gi√¢y

/**
 * G·ª≠i th√¥ng b√°o v·ªÅ IP ƒë√£ truy c·∫≠p website qua Telegram
 * @param {String} ip - ƒê·ªãa ch·ªâ IP ng∆∞·ªùi d√πng
 * @param {String} time - Th·ªùi gian truy c·∫≠p
 * @param {String} userAgent - Th√¥ng tin tr√¨nh duy·ªát
 * @param {String} path - ƒê∆∞·ªùng d·∫´n truy c·∫≠p
 * @param {String} extraInfo - Th√¥ng tin b·ªï sung t·ª´ client
 * @returns {Promise<Boolean>} - True n·∫øu g·ª≠i th√†nh c√¥ng
 */
const sendIPNotification = async (ip, time, userAgent = '', path = '/', extraInfo = '') => {
    // L·∫•y token v√† chat id t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
    const token = process.env.TELEGRAM_BOT_TOKEN;
    const chatId = process.env.TELEGRAM_CHAT_ID;

    // N·∫øu ch∆∞a c√≥ token ho·∫∑c chat id th√¨ kh√¥ng g·ª≠i
    if (!token || !chatId) {
        return false;
    }

    try {
        // Ki·ªÉm tra cache ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng g·ª≠i th√¥ng b√°o qu√° nhanh cho c√πng m·ªôt IP
        const currentTime = Date.now();
        const lastNotificationTime = notificationCache[ip] || 0;

        if (currentTime - lastNotificationTime < MIN_NOTIFICATION_INTERVAL) {
            console.log(`B·ªè qua th√¥ng b√°o cho IP ${ip} (ƒë√£ g·ª≠i g·∫ßn ƒë√¢y)`);
            return false; // Kh√¥ng g·ª≠i th√¥ng b√°o n·∫øu ƒë√£ g·ª≠i g·∫ßn ƒë√¢y
        }

        // C·∫≠p nh·∫≠t cache v·ªõi th·ªùi gian hi·ªán t·∫°i
        notificationCache[ip] = currentTime;

        // D·ªçn d·∫πp cache ƒë·ªãnh k·ª≥ (x√≥a c√°c m·ª•c qu√° c≈©)
        cleanupNotificationCache(currentTime);

        // ƒê·ªãnh d·∫°ng l·∫°i th·ªùi gian ƒë·ªÉ hi·ªÉn th·ªã ch√≠nh x√°c
        let timeDisplay = time;

        // N·∫øu time l√† chu·ªói Date object, ƒë·ªãnh d·∫°ng l·∫°i theo m√∫i gi·ªù Vi·ªát Nam
        if (time instanceof Date) {
            // ƒê·ªãnh d·∫°ng th·ªùi gian theo m√∫i gi·ªù Vi·ªát Nam (UTC+7)
            timeDisplay = new Intl.DateTimeFormat('vi-VN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZone: 'Asia/Ho_Chi_Minh'
            }).format(time);
        }

        // L·∫•y th√¥ng tin v·ªã tr√≠ t·ª´ IP s·ª≠ d·ª•ng geoip-lite (nhanh v√† offline)
        let locationInfo = '';
        try {
            // ∆Øu ti√™n s·ª≠ d·ª•ng t·ªça ƒë·ªô t·ª´ c√°c th√¥ng tin b·ªï sung c·ªßa client
            const hasClientLocation = extraInfo.includes('T·ªça ƒë·ªô:');

            // Ch·ªâ s·ª≠ d·ª•ng lookup IP ƒë·ªÉ ƒë·ªãnh v·ªã n·∫øu kh√¥ng c√≥ th√¥ng tin t·ª´ client
            if (!hasClientLocation) {
                // L√†m s·∫°ch IP n·∫øu c·∫ßn (m·ªôt s·ªë IP c√≥ th·ªÉ c√≥ port ho·∫∑c th√¥ng tin kh√°c)
                const cleanIP = ip.split(":")[0].split(",")[0].trim();

                // M·∫£ng k·∫øt qu·∫£ t·ª´ c√°c d·ªãch v·ª• ƒë·ªãnh v·ªã
                let locationResults = [];

                // 1. ƒê·∫ßu ti√™n th·ª≠ v·ªõi geoip-lite (nhanh v√† kh√¥ng c·∫ßn request m·∫°ng)
                try {
                    const geo = geoip.lookup(cleanIP);
                    if (geo && geo.ll && geo.ll.length === 2) {
                        locationResults.push({
                            source: 'geoip-lite',
                            city: geo.city || 'N/A',
                            country: geo.country || 'N/A',
                            region: geo.region || 'N/A',
                            latitude: geo.ll[0],
                            longitude: geo.ll[1],
                            accuracy: 'low' // ƒê·ªô ch√≠nh x√°c th·∫•p
                        });
                    }
                } catch (err) {
                    // B·ªè qua l·ªói
                }

                // Ch·ªâ s·ª≠ d·ª•ng m·ªôt d·ªãch v·ª• API n·∫øu geoip-lite kh√¥ng c√≥ k·∫øt qu·∫£
                if (locationResults.length === 0) {
                    // ∆Øu ti√™n s·ª≠ d·ª•ng ipapi.co
                    try {
                        const ipInfo = await axios.get(`https://ipapi.co/${cleanIP}/json/`, {
                            timeout: 3000
                        });

                        if (ipInfo.data && ipInfo.data.latitude && ipInfo.data.longitude) {
                            locationResults.push({
                                source: 'ipapi.co',
                                city: ipInfo.data.city || 'N/A',
                                country: ipInfo.data.country_name || 'N/A',
                                region: ipInfo.data.region || 'N/A',
                                latitude: ipInfo.data.latitude,
                                longitude: ipInfo.data.longitude,
                                isp: ipInfo.data.org || 'N/A',
                                accuracy: 'medium' // ƒê·ªô ch√≠nh x√°c trung b√¨nh
                            });
                        }
                    } catch (err) {
                        // B·ªè qua l·ªói v√† kh√¥ng th·ª≠ c√°c d·ªãch v·ª• kh√°c
                    }
                }

                // Ch·ªçn k·∫øt qu·∫£ c√≥ ƒë·ªô ch√≠nh x√°c cao nh·∫•t
                let bestLocation = null;
                const priorityOrder = ['high', 'medium-high', 'medium', 'low'];

                for (const priority of priorityOrder) {
                    const found = locationResults.find(loc => loc.accuracy === priority);
                    if (found) {
                        bestLocation = found;
                        break;
                    }
                }

                // N·∫øu kh√¥ng t√¨m th·∫•y theo ƒë·ªô ∆∞u ti√™n, l·∫•y k·∫øt qu·∫£ ƒë·∫ßu ti√™n c√≥
                if (!bestLocation && locationResults.length > 0) {
                    bestLocation = locationResults[0];
                }

                if (bestLocation) {
                    const latitude = bestLocation.latitude;
                    const longitude = bestLocation.longitude;
                    const locationLink = isValidCoords(latitude, longitude) ?
                        `<a href="https://www.google.com/maps/search/?api=1&query=${latitude},${longitude}">Xem b·∫£n ƒë·ªì</a>` : '';

                    // Th√™m ngu·ªìn d·ªØ li·ªáu v√†o th√¥ng tin
                    const sourceInfo = bestLocation.source ? `(${bestLocation.source})` : '';

                    locationInfo = `
üìç <b>V·ªã tr√≠:</b> ${bestLocation.city || 'N/A'}, ${bestLocation.country || 'N/A'} ${sourceInfo}
üåç <b>Khu v·ª±c:</b> ${bestLocation.region || 'N/A'}
üß≠ <b>T·ªça ƒë·ªô:</b> ${latitude}, ${longitude} ${locationLink}`;

                    if (bestLocation.isp) {
                        locationInfo += `\nüåê <b>ISP:</b> ${bestLocation.isp}`;
                    }
                }
            }
        } catch {
            // B·ªè qua l·ªói khi l·∫•y th√¥ng tin v·ªã tr√≠
        }

        // Ph√¢n t√≠ch User Agent ƒë·ªÉ x√°c ƒë·ªãnh thi·∫øt b·ªã
        let device = 'Kh√¥ng x√°c ƒë·ªãnh';
        let browserInfo = '';

        // Ph√¢n t√≠ch th√¥ng tin tr√¨nh duy·ªát chi ti·∫øt h∆°n
        if (userAgent) {
            // X√°c ƒë·ªãnh lo·∫°i thi·∫øt b·ªã
            if (userAgent.includes('Android')) {
                device = 'Android';
                browserInfo = userAgent.match(/Android [0-9\.]+/)?.[0] || '';
            } else if (userAgent.includes('iPhone')) {
                device = 'iPhone';
                browserInfo = userAgent.match(/iPhone OS [0-9_]+/)?.[0]?.replace(/_/g, '.') || '';
            } else if (userAgent.includes('iPad')) {
                device = 'iPad';
                browserInfo = userAgent.match(/iPad.*OS [0-9_]+/)?.[0]?.replace(/_/g, '.') || '';
            } else if (userAgent.includes('Windows')) {
                device = 'Windows';
                browserInfo = userAgent.match(/Windows NT [0-9\.]+/)?.[0] || '';
            } else if (userAgent.includes('Mac')) {
                device = 'Mac OS';
                browserInfo = userAgent.match(/Mac OS X [0-9_]+/)?.[0]?.replace(/_/g, '.') || '';
            } else if (userAgent.includes('Linux')) {
                device = 'Linux';
            }

            // Th√™m th√¥ng tin tr√¨nh duy·ªát
            const browsers = [
                { name: 'Chrome', pattern: /Chrome\/([0-9\.]+)/ },
                { name: 'Firefox', pattern: /Firefox\/([0-9\.]+)/ },
                { name: 'Safari', pattern: /Safari\/([0-9\.]+)/ },
                { name: 'Edge', pattern: /Edg(e)?\/([0-9\.]+)/ },
                { name: 'Opera', pattern: /OPR\/([0-9\.]+)/ },
            ];

            for (const browser of browsers) {
                const match = userAgent.match(browser.pattern);
                if (match) {
                    browserInfo += ` ${browser.name} ${match[1] || match[2] || ''}`;
                    break;
                }
            }
        }

        // C·∫≠p nh·∫≠t extraInfo ƒë·ªÉ bao g·ªìm li√™n k·∫øt b·∫£n ƒë·ªì cho t·ªça ƒë·ªô n·∫øu c√≥
        if (extraInfo) {
            // T√¨m v√† c·∫≠p nh·∫≠t d√≤ng t·ªça ƒë·ªô n·∫øu c√≥
            const coordsMatch = extraInfo.match(/üìç T·ªça ƒë·ªô: ([0-9.-]+), ([0-9.-]+)/);
            if (coordsMatch && coordsMatch.length >= 3) {
                const lat = coordsMatch[1];
                const lng = coordsMatch[2];
                if (isValidCoords(lat, lng)) {
                    extraInfo = extraInfo.replace(
                        coordsMatch[0],
                        `üìç T·ªça ƒë·ªô: ${lat}, ${lng} - <a href="https://www.google.com/maps/search/?api=1&query=${lat},${lng}">Xem b·∫£n ƒë·ªì</a>`
                    );
                }
            }
        }

        // Kh·ªüi t·∫°o bot v·ªõi token
        const bot = new TelegramBot(token, { polling: false });

        // Format n·ªôi dung th√¥ng b√°o v·ªõi th√¥ng tin chi ti·∫øt h∆°n
        const message = `
üö® <b>C√≥ ng∆∞·ªùi truy c·∫≠p website!</b>

üì± <b>IP:</b> ${ip}
‚è∞ <b>Th·ªùi gian:</b> ${timeDisplay}
üåê <b>ƒê∆∞·ªùng d·∫´n:</b> ${path}
üñ•Ô∏è <b>Thi·∫øt b·ªã:</b> ${device} ${browserInfo}
${locationInfo}

${extraInfo ? `<b>Th√¥ng tin b·ªï sung:</b>\n${extraInfo}` : ''}

${hasAddressInfo(extraInfo) ? getMapsLink(extraInfo) : ''}`;

        // G·ª≠i th√¥ng b√°o qua Telegram
        await bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
        return true;
    } catch {
        // B·ªè qua t·∫•t c·∫£ l·ªói, kh√¥ng log ra console
        return false;
    }
};

/**
 * D·ªçn d·∫πp cache th√¥ng b√°o, x√≥a c√°c m·ª•c qu√° c≈©
 * @param {Number} currentTime - Th·ªùi gian hi·ªán t·∫°i
 */
function cleanupNotificationCache(currentTime) {
    // X√≥a c√°c m·ª•c c≈© h∆°n 1 gi·ªù (ƒë·ªÉ tr√°nh r√≤ r·ªâ b·ªô nh·ªõ)
    const ONE_HOUR = 3600000;
    for (const ip in notificationCache) {
        if (currentTime - notificationCache[ip] > ONE_HOUR) {
            delete notificationCache[ip];
        }
    }
}

/**
 * Ki·ªÉm tra xem t·ªça ƒë·ªô c√≥ h·ª£p l·ªá kh√¥ng
 * @param {any} lat - Vƒ© ƒë·ªô
 * @param {any} lng - Kinh ƒë·ªô
 * @returns {boolean} - True n·∫øu t·ªça ƒë·ªô h·ª£p l·ªá
 */
function isValidCoords(lat, lng) {
    lat = parseFloat(lat);
    lng = parseFloat(lng);
    return !isNaN(lat) && !isNaN(lng) &&
        lat >= -90 && lat <= 90 &&
        lng >= -180 && lng <= 180;
}

/**
 * Ki·ªÉm tra xem c√≥ th√¥ng tin ƒë·ªãa ch·ªâ trong extraInfo kh√¥ng
 * @param {String} extraInfo - Th√¥ng tin b·ªï sung
 * @returns {Boolean} - True n·∫øu c√≥ th√¥ng tin ƒë·ªãa ch·ªâ
 */
function hasAddressInfo(extraInfo) {
    return extraInfo && (
        extraInfo.includes('ƒê·ªãa ch·ªâ:') ||
        extraInfo.includes('Chi ti·∫øt:') ||
        extraInfo.includes('V·ªã tr√≠ t·ª´ IP') ||
        extraInfo.includes('T·ªça ƒë·ªô')
    );
}

/**
 * T·∫°o li√™n k·∫øt ƒë·∫øn Google Maps d·ª±a tr√™n t·ªça ƒë·ªô ho·∫∑c ƒë·ªãa ch·ªâ
 * @param {String} extraInfo - Th√¥ng tin b·ªï sung
 * @returns {String} - HTML ch·ª©a li√™n k·∫øt ƒë·∫øn Google Maps
 */
function getMapsLink(extraInfo) {
    // ∆Øu ti√™n t√¨m t·ªça ƒë·ªô ch√≠nh x√°c t·ª´ extraInfo
    const coordsMatch = extraInfo.match(/üìç T·ªça ƒë·ªô[^:]*: ([0-9.-]+), ([0-9.-]+)/);
    if (coordsMatch && coordsMatch.length >= 3) {
        const lat = coordsMatch[1];
        const lng = coordsMatch[2];
        if (isValidCoords(lat, lng)) {
            return `<a href="https://www.google.com/maps?q=${lat},${lng}">üó∫Ô∏è Xem v·ªã tr√≠ ch√≠nh x√°c tr√™n Google Maps</a>`;
        }
    }

    // N·∫øu kh√¥ng t√¨m th·∫•y t·ªça ƒë·ªô ch√≠nh x√°c, t√¨m t·ªça ƒë·ªô t·ª´ IP
    const ipCoordsMatch = extraInfo.match(/üìå V·ªã tr√≠ t·ª´ IP[^:]*: ([0-9.-]+), ([0-9.-]+)/);
    if (ipCoordsMatch && ipCoordsMatch.length >= 3) {
        const lat = ipCoordsMatch[1];
        const lng = ipCoordsMatch[2];
        if (isValidCoords(lat, lng)) {
            return `<a href="https://www.google.com/maps?q=${lat},${lng}">üó∫Ô∏è Xem v·ªã tr√≠ IP tr√™n Google Maps</a>`;
        }
    }

    // N·∫øu c√≥ ƒë·ªãa ƒëi·ªÉm IP
    const ipLocationMatch = extraInfo.match(/üèôÔ∏è ƒê·ªãa ƒëi·ªÉm IP: ([^,]+), ([^,\n]+)/);
    if (ipLocationMatch && ipLocationMatch.length >= 3) {
        const city = encodeURIComponent(ipLocationMatch[1]);
        const country = encodeURIComponent(ipLocationMatch[2]);
        return `<a href="https://www.google.com/maps/search/?api=1&query=${city}+${country}">üó∫Ô∏è Xem th√†nh ph·ªë tr√™n Google Maps</a>`;
    }

    // N·∫øu kh√¥ng c√≥ t·ªça ƒë·ªô nh∆∞ng c√≥ ƒë·ªãa ch·ªâ, t√¨m ƒë·ªãa ch·ªâ
    const addressMatch = extraInfo.match(/üè° ƒê·ªãa ch·ªâ: (.*?)(?:\n|$)/);
    if (addressMatch && addressMatch.length >= 2) {
        const address = encodeURIComponent(addressMatch[1]);
        return `<a href="https://www.google.com/maps/search/?api=1&query=${address}">üó∫Ô∏è Xem ƒë·ªãa ch·ªâ tr√™n Google Maps</a>`;
    }

    // N·∫øu c√≥ th√¥ng tin chi ti·∫øt ƒë·ªãa ch·ªâ
    const detailMatch = extraInfo.match(/üìÆ Chi ti·∫øt: (.*?)(?:\n|$)/);
    if (detailMatch && detailMatch.length >= 2) {
        const detail = encodeURIComponent(detailMatch[1]);
        return `<a href="https://www.google.com/maps/search/?api=1&query=${detail}">üó∫Ô∏è Xem ƒë·ªãa ƒëi·ªÉm tr√™n Google Maps</a>`;
    }

    // N·∫øu c√≥ v√πng ∆∞·ªõc t√≠nh
    const regionMatch = extraInfo.match(/üåé V√πng ∆∞·ªõc t√≠nh: ([^,]+), ([^,\n]+)/);
    if (regionMatch && regionMatch.length >= 3) {
        const continent = encodeURIComponent(regionMatch[1]);
        const city = encodeURIComponent(regionMatch[2]);
        return `<a href="https://www.google.com/maps/search/?api=1&query=${city}+${continent}">üó∫Ô∏è Xem v√πng ∆∞·ªõc t√≠nh tr√™n Google Maps</a>`;
    }

    return '';
}

module.exports = sendIPNotification; 